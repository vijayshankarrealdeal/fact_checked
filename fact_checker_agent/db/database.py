# fact_checker_agent/db/database.py

import os
import asyncio
from google.adk.sessions import DatabaseSessionService
from dotenv import load_dotenv

load_dotenv()

# --- Database Configuration (Unchanged) ---
DB_USER = os.getenv("POSTGRES_USER")
DB_PASSWORD = os.getenv("POSTGRES_PASSWORD")
DB_NAME = os.getenv("POSTGRES_NAME")
DB_HOST = os.getenv("POSTGRES_HOST")
DB_PORT = 5432

DB_URL = f"postgresql://{DB_USER}:{DB_PASSWORD}@{DB_HOST}:{DB_PORT}/{DB_NAME}"

# --- Session Service Initialization (Unchanged) ---
session_service = DatabaseSessionService(db_url=DB_URL)


# --- Core Async Functions (Unchanged) ---
async def list_sessions(user_id: str):
    """Lists all sessions for a given user."""
    return await session_service.list_sessions(
        app_name="FactCheckerADK", user_id=user_id
    )

async def get_session(session_id: str, user_id: str):
    """Retrieves a specific session by its ID. Returns None if not found."""
    return await session_service.get_session(
        app_name="FactCheckerADK", user_id=user_id, session_id=session_id
    )

async def create_new_session(user_id: str):
    """Creates a new session with a random ID generated by ADK."""
    initial_state = {
        "user_name": user_id, "search_query": "", "gathered_urls": {},
        "web_analysis": "", "video_analysis": "", "final_fact_check_result": {},
    }
    return await session_service.create_session(
        app_name="FactCheckerADK", user_id=user_id, state=initial_state
    )

# --- ASYNC and SYNC Functions ---

async def get_session_history_async(session_id: str, user_id: str):
    """Asynchronously retrieves chat history."""
    session = await get_session(session_id, user_id)
    history = []
    if session and session.messages:
        for msg in session.messages:
            role = "user" if msg.role == "user" else "assistant"
            if msg.parts and hasattr(msg.parts[0], "text"):
                history.append({"role": role, "content": msg.parts[0].text})
    return history

# --- START: THE FINAL FIX IS HERE ---
async def ensure_session_exists_async(session_id: str, user_id: str):
    """
    Asynchronously and reliably checks if a session exists. If not, it creates it.
    This version directly checks for the session object's existence, which is the
    correct way to prevent race conditions and duplicate creation attempts.
    """
    # THE FIX: Call get_session directly. It returns a session object or None.
    # This is the most reliable way to check for existence.
    existing_session = await get_session(session_id, user_id)

    # If the session is None, it truly does not exist. It's now safe to create it.
    if existing_session is None:
        print(f"Session '{session_id}' not found. Creating it now.")
        initial_state = {
            "user_name": user_id, "search_query": "", "gathered_urls": {},
            "web_analysis": "", "video_analysis": "", "final_fact_check_result": {},
        }
        await session_service.create_session(
            app_name="FactCheckerADK",
            user_id=user_id,
            state=initial_state,
            session_id=session_id
        )
        print(f"Database: Successfully created session with specific ID '{session_id}'.")
    else:
        # If the session object exists, we do nothing and proceed.
        print(f"Session '{session_id}' found. Proceeding with query.")

# --- END OF THE FIX ---

def get_session_history_sync(session_id: str, user_id: str):
    """Synchronous wrapper to retrieve chat history."""
    return asyncio.run(get_session_history_async(session_id, user_id))

def list_sessions_sync(user_id: str):
    """Synchronous wrapper to list sessions."""
    return asyncio.run(list_sessions(user_id))